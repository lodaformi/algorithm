#给你一个大小为 m * n 的矩阵 mat 。

#要求：以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
#

class Solution(object):
    def findDiagonalOrder(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: List[int]
        """
        #这种思路有缺陷，对于坐标的判断必须区分先后，不太好
        #先来一个简单的解法，思路：画个图，看图找规律
        #在对角线方向上，元素的行坐标+纵坐标分为两种情况，偶数和奇数
        #偶数对角线向右上走，奇数对角线向左下走
        #偶数对角线分三种情况：
            #情况1：与奇数对角线相交，在第一行
                #下次的走向是纵坐标+1
            #情况2：与奇数对角线相交，在第一列
                #下次的走向是横坐标+1
            #情况3：其他
                #下次的走向是横坐标-1，纵坐标+1
        #奇数对角线分三种情况：
            #情况1：与偶数对角线相交，在第一列
                #下次的走向是横坐标+1
            #情况2：与偶数对角线相交，在最后一行
                #下次的走向是纵坐标+1
            #情况3：其他
                #下次的走向是横坐标+1，纵坐标-1

        rows = len(mat)
        cols = len(mat[0])

        resList = [] #用于存放结果
        x, y = 0, 0  #初始元素坐标，后续跟随者对角线方向变化

        while (len(resList) < rows*cols):
        # for i in range(rows*cols):
            resList.append(mat[x][y])
            if (x+y) % 2 == 0:        #偶数对角线
                if  y == cols - 1:    #最后一列，必须先判断，对照3*3的矩阵，如果先判断x==0，则x==0先成立，不符合实际情况，同时越界
                    x += 1
                elif x == 0:          #第一行
                    y += 1
                else:
                    x -= 1
                    y += 1
            else:                   #奇数对角线                            
                if x == rows - 1:   #最后一行，必须先判断
                    y += 1
                elif y == 0:        #第一列
                    x += 1
                else:
                    x += 1
                    y -= 1

        return resList


